# 全局对象与全局函数

[TOC]

---

在浏览器环境中，`window` 对象既是 BOM 的顶层对象，也是 JavaScript 的全局对象。它代表整个浏览器窗口或标签页，并且所有在全局作用域中声明的变量和函数都会成为它的属性或方法。此外，浏览器还内置了大量可直接使用的全局函数，它们挂载在 `window` 上，用于执行各种常见任务（如对话框、定时器、编解码等）。理解这些全局对象和函数，是掌握浏览器端 JavaScript 编程的基础。

---

## 1. 全局对象 window

### 1.1 概述

`window` 对象是浏览器中的全局对象，它具有双重身份：

- **BOM 的核心对象**：表示浏览器窗口，提供了操作窗口的属性和方法（如 `window.innerWidth`、`window.open()`）。
- **ECMAScript 的全局对象**：所有在全局作用域中使用 `var` 声明的变量、函数声明以及某些内置对象都会成为 `window` 的属性。

```javascript
var globalVar = 'Hello';
function globalFunc() {}
console.log(window.globalVar); // "Hello"
console.log(window.globalFunc); // function globalFunc()
```

**注意**：使用 `let`、`const` 或 `class` 在全局作用域声明的标识符**不会**成为 `window` 的属性，但它们仍然是全局作用域的一部分，可以通过直接名称访问。

```javascript
let letVar = 'Not on window';
console.log(window.letVar); // undefined
console.log(letVar); // "Not on window"
```

### 1.2 引用 window 的方式

除了直接使用 `window` 外，还有以下几种方式引用全局对象：

- **`self`**：指向 `window`，通常用于 Web Worker 或窗口自身引用。
- **`frames`**：当前窗口的所有子框架的集合，`self` 指向 `window`。
- **`globalThis`**（ES2020）：提供了一种标准方式访问全局对象，无论在浏览器还是 Node.js 环境。

```javascript
console.log(window === self); // true
console.log(globalThis === window); // true
```

### 1.3 window 作为浏览器窗口的接口

`window` 提供了大量属性和方法，用于控制窗口本身：

- **尺寸与位置**：`innerWidth`、`innerHeight`、`outerWidth`、`outerHeight`、`screenX`、`screenY`。
- **滚动控制**：`scrollX`、`scrollY`、`scrollTo()`、`scrollBy()`。
- **窗口操作**：`open()`、`close()`、`stop()`、`focus()`、`blur()`。
- **历史与导航**：`location`、`history`、`navigator` 等（这些本身也是对象，将在后续章节详述）。

---

## 2. 全局函数

浏览器环境中挂载在 `window` 上的全局函数非常丰富，涵盖了输入输出、定时、编解码、类型转换等多个方面。下面按类别介绍最常用的全局函数。

### 2.1 对话框函数

| 函数                        | 描述                                                                  |
| --------------------------- | --------------------------------------------------------------------- |
| `alert(message)`            | 显示一个带有“确定”按钮的模态对话框，仅用于提示信息。                  |
| `confirm(message)`          | 显示带有“确定”和“取消”按钮的对话框，返回布尔值。                      |
| `prompt(message, default?)` | 显示一个可输入文本的对话框，返回用户输入的字符串，取消则返回 `null`。 |

```javascript
const name = prompt('请输入你的名字', '访客');
if (name) {
  alert(`你好，${name}！`);
} else {
  alert('你没有输入名字');
}
```

### 2.2 定时器与动画帧

| 函数                                       | 描述                                              |
| ------------------------------------------ | ------------------------------------------------- |
| `setTimeout(callback, delay, ...args)`     | 延迟 `delay` 毫秒后执行回调，返回定时器 ID。      |
| `clearTimeout(id)`                         | 取消由 `setTimeout` 设置的定时器。                |
| `setInterval(callback, interval, ...args)` | 每隔 `interval` 毫秒重复执行回调，返回定时器 ID。 |
| `clearInterval(id)`                        | 取消由 `setInterval` 设置的定时器。               |
| `requestAnimationFrame(callback)`          | 在下一次浏览器重绘前执行回调，返回 ID。           |
| `cancelAnimationFrame(id)`                 | 取消 `requestAnimationFrame` 请求。               |
| `requestIdleCallback(callback, options?)`  | 在浏览器空闲时段执行低优先级回调。                |
| `cancelIdleCallback(id)`                   | 取消 `requestIdleCallback` 请求。                 |

**示例**：

```javascript
// 延迟执行
const timer = setTimeout(() => console.log('执行'), 1000);
clearTimeout(timer);

// 动画循环
function animate() {
  // 更新动画
  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);
```

### 2.3 编解码函数

用于处理 URL 和 Base64 编码：

| 函数                                   | 描述                                                              |
| -------------------------------------- | ----------------------------------------------------------------- |
| `encodeURI(uri)`                       | 对 URI 进行编码，但不会编码属于 URI 特殊字符的字符（如 `:/?#`）。 |
| `decodeURI(encodedURI)`                | 对 `encodeURI` 编码的 URI 进行解码。                              |
| `encodeURIComponent(uriComponent)`     | 对 URI 组件进行编码，会编码所有特殊字符。                         |
| `decodeURIComponent(encodedComponent)` | 对 `encodeURIComponent` 编码的组件进行解码。                      |
| `atob(encodedData)`                    | 解码 Base64 编码的字符串。                                        |
| `btoa(stringToEncode)`                 | 将字符串编码为 Base64（仅支持 ASCII 字符）。                      |

```javascript
const url = 'https://example.com/?name=张三';
const encoded = encodeURI(url);
console.log(encoded); // "https://example.com/?name=%E5%BC%A0%E4%B8%89"
console.log(decodeURI(encoded)); // 还原

const base64 = btoa('Hello');
console.log(base64); // "SGVsbG8="
console.log(atob(base64)); // "Hello"
```

### 2.4 类型转换与判断函数

这些函数是 ECMAScript 语言核心的一部分，但在浏览器中也是全局可用：

| 函数                       | 描述                   |
| -------------------------- | ---------------------- |
| `parseInt(string, radix?)` | 解析字符串为整数。     |
| `parseFloat(string)`       | 解析字符串为浮点数。   |
| `isNaN(value)`             | 判断值是否为 `NaN`。   |
| `isFinite(value)`          | 判断值是否为有限数值。 |
| `Number(value)`            | 将值转换为数字。       |
| `String(value)`            | 将值转换为字符串。     |
| `Boolean(value)`           | 将值转换为布尔值。     |

**注意**：`isNaN` 和 `isFinite` 在转换时会先强制类型转换，推荐使用更严格的 `Number.isNaN()` 和 `Number.isFinite()`（但它们是 `Number` 的静态方法，不是全局函数）。

### 2.5 其他全局函数

| 函数                 | 描述                                                             |
| -------------------- | ---------------------------------------------------------------- |
| `eval(string)`       | 执行字符串中的 JavaScript 代码（强烈不建议使用，存在安全风险）。 |
| `uneval()`           | 非标准，返回对象的源代码表示（仅 Firefox 支持）。                |
| `getComputedStyle()` | 返回元素的计算样式（实际是 `window` 的方法）。                   |
| `matchMedia()`       | 返回媒体查询对象（实际是 `window` 的方法）。                     |

---

## 3. 重要的内置对象属性

`window` 对象还拥有许多重要的内置对象，它们各自封装了一组相关的功能：

| 属性             | 描述                                      | 章节                          |
| ---------------- | ----------------------------------------- | ----------------------------- |
| `document`       | 文档对象模型（DOM）的根节点。             | 详见 DOM 相关章节             |
| `location`       | 提供当前 URL 信息，并允许导航。           | 详见 BOM.location 与 History  |
| `history`        | 允许操作浏览器的会话历史。                | 详见 BOM.location 与 History  |
| `navigator`      | 提供浏览器和操作系统信息。                | 详见 BOM.navigator 与用户代理 |
| `screen`         | 提供显示器屏幕信息。                      | 详见 BOM.screen 对象          |
| `localStorage`   | 持久化的本地存储。                        | 详见 Web Storage 章节         |
| `sessionStorage` | 会话级别的本地存储。                      | 详见 Web Storage 章节         |
| `console`        | 提供控制台调试方法（`log`、`error` 等）。 | 详见基本调试章节              |
| `performance`    | 提供性能相关数据和计时功能。              | 详见性能优化章节              |
| `crypto`         | 提供基本的加密功能。                      | 详见 Web Crypto API 章节      |

这些对象都可以通过 `window.xxx` 或直接使用 `xxx` 访问（因为它们在全局作用域中）。

```javascript
console.log(window.location === location); // true
console.log(window.localStorage === localStorage); // true
```

---

## 4. 全局变量与函数的挂载规则

了解哪些声明会成为 `window` 的属性，对于避免意外覆盖和优化内存很重要：

- **`var` 声明和函数声明**：在全局作用域中会挂载到 `window` 对象上。
- **`let`、`const` 和 `class` 声明**：在全局作用域中不会挂载到 `window`，但它们仍属于全局词法环境，可以直接访问。
- **未声明的赋值**：在非严格模式下，如果给一个未声明的变量赋值，会隐式创建为全局变量（挂载到 `window`）。**这是应该避免的坏习惯**，严格模式会抛出错误。

```javascript
var a = 1;
let b = 2;
c = 3; // 非严格模式：window.c = 3

console.log(window.a); // 1
console.log(window.b); // undefined
console.log(window.c); // 3
```

**最佳实践**：尽量使用模块化（ES6 模块）或立即执行函数（IIFE）来封装作用域，避免向全局对象添加不必要的属性。

---

## 5. 注意事项

### 5.1 命名冲突

由于大量第三方库和广告脚本都会在全局作用域中声明变量，极易发生命名冲突。推荐的做法：

- 将自己的逻辑封装在模块或闭包内。
- 使用唯一的命名空间对象（如 `window.MyApp = {}`）。
- 使用 ES6 模块，它们不会污染全局作用域。

### 5.2 跨窗口通信

当页面包含 `<iframe>` 或通过 `window.open()` 打开新窗口时，不同窗口的全局对象是相互独立的。但可以通过 `window.parent`、`window.top` 和 `window.frames` 访问其他窗口的全局对象。跨窗口通信应优先使用 `postMessage` 而不是直接访问全局变量。

### 5.3 严格模式下的 this

在全局作用域中，`this` 指向 `window`（严格模式下也指向 `window`，因为全局 `this` 始终指向全局对象）。但在函数内部，如果函数不是作为方法调用，且处于严格模式，`this` 会是 `undefined`。

### 5.4 不要滥用全局函数

虽然全局函数使用方便，但过度依赖可能导致代码难以测试和维护。例如，对话框会阻塞事件循环，应仅在必要时使用；`eval` 会带来严重的安全风险，永远不要使用。

### 5.5 浏览器兼容性

大多数全局函数在所有现代浏览器中都有良好支持，但某些较新的（如 `requestIdleCallback`）在 Safari 中可能尚未实现。使用时建议进行特性检测：

```javascript
if (window.requestIdleCallback) {
  requestIdleCallback(task);
} else {
  setTimeout(task, 0); // 降级方案
}
```

---

## 6. 小结

浏览器中的全局对象 `window` 是连接 JavaScript 语言与浏览器环境的枢纽。本章介绍了：

- **`window` 作为全局对象**：其双重身份、引用方式及窗口控制功能。
- **主要全局函数**：对话框、定时器、编解码、类型转换等，并提供代码示例。
- **重要的内置对象属性**：`document`、`location`、`navigator` 等，它们是 BOM 的核心组成部分。
- **变量挂载规则**：理解哪些声明会污染全局对象，并养成良好编码习惯。
- **注意事项**：命名冲突、跨窗口通信、安全性及兼容性。

掌握全局对象和函数，你将能够灵活调用浏览器提供的各种能力，为构建复杂 Web 应用打下坚实基础。在后续章节中，我们将深入探讨每个子对象的细节，帮助你更全面地掌控浏览器环境。
