# location* 与 history

[TOC]

---

`location` 和 `history` 是浏览器对象模型（BOM）中两个至关重要的对象，它们都与当前页面的 URL 和浏览历史密切相关。`location` 对象提供了访问和操作当前页面 URL 的能力，而 `history` 对象则允许我们以编程方式操作浏览器的会话历史（前进、后退、添加历史条目）。理解这两个对象对于构建现代单页应用（SPA）和处理页面导航至关重要。

---

## 1. location 对象

### 1.1 概述

`window.location` 对象包含了当前页面 URL 的详细信息，并提供了导航到新 URL 或重新加载当前页面的方法。它既是 `window` 的属性，也可以直接通过 `location` 访问（在全局作用域中）。

```javascript
console.log(window.location === location); // true
```

### 1.2 URL 结构解析

一个完整的 URL 通常包含以下部分（以 `https://example.com:8080/path/index.html?name=Alice#section` 为例）：

| 属性       | 示例                                                          | 描述                                   |
| ---------- | ------------------------------------------------------------- | -------------------------------------- |
| `href`     | `https://example.com:8080/path/index.html?name=Alice#section` | 完整的 URL。                           |
| `protocol` | `https:`                                                      | 协议（包括末尾的冒号）。               |
| `host`     | `example.com:8080`                                            | 主机名和端口号。                       |
| `hostname` | `example.com`                                                 | 主机名（不包括端口）。                 |
| `port`     | `8080`                                                        | 端口号，如果没有显式指定则为空字符串。 |
| `pathname` | `/path/index.html`                                            | URL 的路径部分。                       |
| `search`   | `?name=Alice`                                                 | 查询字符串（包括开头的 `?`）。         |
| `hash`     | `#section`                                                    | 片段标识符（包括开头的 `#`）。         |
| `origin`   | `https://example.com:8080`                                    | 协议 + 主机名 + 端口（只读）。         |

```javascript
console.log(location.protocol); // "https:"
console.log(location.host);     // "example.com:8080"
console.log(location.pathname); // "/path/index.html"
console.log(location.search);   // "?name=Alice"
console.log(location.hash);     // "#section"
```

### 1.3 常用方法

#### `assign(url)`

加载指定的 URL，会在历史记录中添加一条新记录。

```javascript
location.assign('https://www.example.com');
```

#### `replace(url)`

用指定的 URL 替换当前页面，不会在历史记录中留下记录（用户无法通过“后退”返回原页面）。

```javascript
location.replace('https://www.example.com');
```

#### `reload(forcedReload?)`

重新加载当前页面。如果传入 `true`，则强制从服务器重新加载（不使用缓存）；否则可能从缓存加载。

```javascript
location.reload();      // 可能使用缓存
location.reload(true);  // 强制从服务器加载
```

### 1.4 修改 location 属性

可以通过直接修改 `location` 对象的属性来改变当前 URL。大多数属性的修改会导致页面重新加载（除非只修改 `hash`）。

```javascript
// 修改 hash 不会刷新页面，但会在历史记录中添加条目
location.hash = 'newSection';

// 修改其他属性会刷新页面
location.pathname = '/new/path';
location.search = '?page=2';
```

也可以直接为 `location` 赋值字符串，相当于调用 `assign()`：

```javascript
location = 'https://example.com'; // 相当于 location.assign('https://example.com')
```

### 1.5 URLSearchParams 处理查询字符串

`location.search` 返回的是原始查询字符串，手动解析很繁琐。现代浏览器提供了 `URLSearchParams` 接口来方便地操作查询参数。

```javascript
// 假设当前 URL 为 https://example.com/?name=Alice&age=30

const params = new URLSearchParams(location.search);
console.log(params.get('name')); // "Alice"
console.log(params.get('age'));  // "30"
params.set('age', '31');
params.append('city', 'Beijing');

// 更新 search（会刷新页面）
location.search = params.toString(); // "?name=Alice&age=31&city=Beijing"
```

### 1.6 示例：获取和修改 URL

```javascript
// 获取当前页面来源
function getSource() {
  const ref = document.referrer; // 不是 location 的属性，但很有用
  return ref || '直接访问';
}

// 添加 utm 参数后跳转
function addTrackingAndRedirect() {
  const params = new URLSearchParams(location.search);
  params.set('utm_source', 'newsletter');
  params.set('utm_campaign', 'summer_sale');
  location.search = params.toString(); // 刷新页面
}
```

---

## 2. history 对象

### 2.1 概述

`window.history` 对象提供了操作浏览器会话历史的接口。它允许我们在用户的历史记录中前进、后退，以及添加或修改历史条目（这对于单页应用尤其重要，可以实现无刷新导航但保留前进/后退功能）。

### 2.2 基本属性与方法

#### 属性

- **`length`**：返回历史记录中的条目数量（包括当前页面）。

```javascript
console.log(history.length); // 当前会话中的历史条目数
```

#### 方法

- **`back()`**：加载历史记录中的前一个页面，等同于用户点击浏览器的后退按钮。
- **`forward()`**：加载历史记录中的下一个页面，等同于用户点击前进按钮。
- **`go(delta)`**：加载历史记录中相对于当前页面的特定页面。`delta` 为正数表示前进，负数表示后退。例如 `history.go(-2)` 后退两个页面。

```javascript
history.back();   // 后退一页
history.forward();// 前进一页
history.go(-2);   // 后退两页
history.go(1);    // 前进一页
```

### 2.3 操作历史状态：HTML5 History API

HTML5 引入了两个重要方法，允许我们添加或修改历史条目而不会触发页面刷新：

- **`pushState(state, title, url?)`**：向历史栈中添加一个新条目。
- **`replaceState(state, title, url?)`**：替换当前历史条目。

这两个方法都接受三个参数：

- **`state`**：一个可序列化的对象，与历史条目相关联，可以在 `popstate` 事件中获取。
- **`title`**：通常被浏览器忽略，可以传空字符串或简短标题。
- **`url`**：可选的新 URL，必须与当前页面同源。浏览器地址栏会更新，但不会加载该 URL。

```javascript
// 添加一个历史条目
history.pushState({ page: 1 }, 'Page 1', '/page1');

// 替换当前历史条目
history.replaceState({ page: 2 }, 'Page 2', '/page2');
```

### 2.4 popstate 事件

当用户点击浏览器的前进/后退按钮，或者调用 `history.back()`、`history.forward()`、`history.go()` 时，会触发 `popstate` 事件。事件对象包含一个 `state` 属性，即与当前历史条目关联的状态对象。

```javascript
window.addEventListener('popstate', (event) => {
  console.log('当前状态:', event.state);
  // 根据状态更新页面内容（例如通过 AJAX 加载新内容）
});
```

**注意**：`pushState()` 和 `replaceState()` 本身不会触发 `popstate` 事件。

### 2.5 单页应用路由基础

利用 `pushState` 和 `popstate` 可以实现前端路由（无刷新导航）。基本原理：

1. 监听页面内导航链接的点击事件，阻止默认跳转。
2. 调用 `pushState` 更新 URL，并异步获取新内容渲染页面。
3. 监听 `popstate` 事件，根据当前 URL 恢复对应页面。

```javascript
// 处理导航链接
document.querySelectorAll('a.nav-link').forEach(link => {
  link.addEventListener('click', (e) => {
    e.preventDefault();
    const url = link.getAttribute('href');
    // 更新历史状态
    history.pushState({ path: url }, '', url);
    // 加载新内容
    loadContent(url);
  });
});

// 监听前进/后退
window.addEventListener('popstate', (e) => {
  const path = e.state ? e.state.path : location.pathname;
  loadContent(path);
});

// 异步加载内容
function loadContent(url) {
  fetch(url)
    .then(res => res.text())
    .then(html => {
      document.getElementById('content').innerHTML = html;
    });
}
```

### 2.6 与 hash 的区别

在 HTML5 History API 出现之前，单页应用常通过监听 `hashchange` 事件和修改 `location.hash` 来实现路由。两者的区别：

- **hash 路由**：只改变 URL 的片段部分（#后面的内容），不会刷新页面，且兼容性好。但 URL 中多了一个 `#`，不够美观。
- **history 路由**：可以实现真正的路径（无 `#`），URL 更自然。但需要服务器配合，对于任何路径都应返回同一 HTML 文件（否则直接访问子路径会 404）。

现代框架（如 React Router、Vue Router）都支持两种模式。

---

## 3. 综合示例：模拟简单的页面导航

以下示例结合 `location` 和 `history` 实现一个简单的无刷新导航，同时演示了获取当前页面来源和修改 URL 参数。

```html
<!DOCTYPE html>
<html>
<head>
  <title>History API 示例</title>
</head>
<body>
  <nav>
    <a href="/home" class="nav-link">首页</a>
    <a href="/about" class="nav-link">关于</a>
    <a href="/contact" class="nav-link">联系</a>
  </nav>
  <div id="content">点击导航加载内容...</div>

  <script>
    // 内容映射（模拟）
    const pages = {
      '/home': '<h1>首页</h1><p>欢迎来到首页</p>',
      '/about': '<h1>关于</h1><p>这是一个关于页面</p>',
      '/contact': '<h1>联系</h1><p>联系方式：example@email.com</p>'
    };

    function loadContent(path) {
      document.getElementById('content').innerHTML = pages[path] || '<h1>404</h1><p>页面不存在</p>';
    }

    // 处理导航点击
    document.querySelectorAll('.nav-link').forEach(link => {
      link.addEventListener('click', (e) => {
        e.preventDefault();
        const path = link.getAttribute('href');
        // 只有路径不同时才更新
        if (location.pathname !== path) {
          history.pushState({ path }, '', path);
          loadContent(path);
        }
      });
    });

    // 监听前进/后退
    window.addEventListener('popstate', (e) => {
      const path = e.state ? e.state.path : location.pathname;
      loadContent(path);
    });

    // 页面初始化时根据当前路径加载内容（例如直接访问 /about）
    window.addEventListener('load', () => {
      loadContent(location.pathname);
    });

    // 添加一个查询参数修改按钮
    const btn = document.createElement('button');
    btn.textContent = '添加查询参数 ?ref=spa';
    btn.addEventListener('click', () => {
      const params = new URLSearchParams(location.search);
      params.set('ref', 'spa');
      history.pushState({}, '', `${location.pathname}?${params.toString()}`);
    });
    document.body.appendChild(btn);
  </script>
</body>
</html>
```

---

## 4. 最佳实践与注意事项

1. **修改 `location` 属性导致页面刷新**：除了 `hash`，修改其他属性都会触发页面重新加载。如果需要无刷新更新 URL，应使用 `history.pushState`。

2. **使用 `replace` 避免历史污染**：在某些场景（如重定向、表单提交后跳转到结果页），可能不希望用户点击“后退”回到表单页，应使用 `location.replace`。

3. **单页应用中的 404 处理**：使用 History 模式时，服务器需配置所有路径返回同一 HTML 文件（如 `index.html`），否则直接访问子路径会 404。

4. **状态对象的可序列化性**：传递给 `pushState` 的 `state` 对象必须是可序列化的（能被结构化克隆算法处理）。不要包含函数、DOM 节点等。

5. **`popstate` 事件的触发时机**：仅在用户点击前进/后退或调用 `go`/`back`/`forward` 时触发，`pushState` 和 `replaceState` 不会触发。

6. **安全性考虑**：使用 `postMessage` 与跨域窗口通信时，务必验证 `event.origin`；在修改 URL 时确保不会引入开放重定向漏洞。

7. **hash 与 SEO**：传统搜索引擎对 hash 路由的支持有限，如果注重 SEO，推荐使用 History 模式并配合服务端渲染。

8. **处理用户直接输入 URL**：无论使用何种路由，都应确保服务端能正确处理用户直接访问的 URL。

---

## 小结

`location` 和 `history` 是 BOM 中用于导航和历史管理的核心对象。通过 `location`，我们可以细粒度地控制当前页面的 URL 并实现跳转；通过 `history`，我们可以无刷新地改变 URL 并管理历史栈，这是现代单页应用的基础。

掌握这两个对象，你就能构建出更流畅、更接近原生应用体验的 Web 应用。在实际开发中，通常不需要直接操作它们（框架会封装），但理解其原理对于调试和性能优化至关重要。
