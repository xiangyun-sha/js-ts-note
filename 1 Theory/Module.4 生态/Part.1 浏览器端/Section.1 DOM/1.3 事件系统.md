# 生态系统 · 浏览器端 · 事件系统

事件是用户与网页交互的核心机制。无论是点击按钮、移动鼠标、按下键盘，还是页面加载完成，都会触发相应的事件。浏览器允许我们监听这些事件并执行自定义逻辑，从而创建动态、响应式的用户体验。本章将深入介绍 JavaScript 事件系统的工作原理、事件流、事件监听、事件对象、常用事件类型以及高级模式（如事件委托和自定义事件），帮助你全面掌握事件编程。

---

## 1. 概述

### 1.1 什么是事件？

事件是浏览器中发生的动作或发生的事情，它由用户触发（如点击、按键）或由系统触发（如页面加载完成、定时器到期）。浏览器提供了一个事件模型，允许开发者注册回调函数（称为事件处理器或监听器）来响应这些事件。

### 1.2 事件模型的核心概念

- **事件目标（Event Target）**：触发事件的对象，通常是元素节点、`document`、`window` 等。
- **事件监听器（Event Listener）**：当事件发生时被调用的函数。
- **事件对象（Event Object）**：包含事件相关信息（如事件类型、目标元素、鼠标坐标等）的对象，会作为参数传递给监听器。
- **事件流（Event Flow）**：描述事件从触发到完成响应的传播过程，分为捕获阶段、目标阶段和冒泡阶段。

---

## 2. 事件流：捕获与冒泡

### 2.1 三个阶段

当一个事件发生时，它会在 DOM 树中经历三个阶段：

1. **捕获阶段（Capturing Phase）**：事件从 `window` 向下传播，逐级经过祖先元素，直到目标元素的父元素。在此阶段注册的监听器会先被执行。
2. **目标阶段（Target Phase）**：事件到达目标元素，触发目标元素上注册的监听器。
3. **冒泡阶段（Bubbling Phase）**：事件从目标元素向上传播，逐级经过祖先元素，直到 `window`。大多数事件都会冒泡。

```text
                捕获阶段                 冒泡阶段
window           ↓                        ↑
document         ↓                        ↑
html             ↓                        ↑
body             ↓                        ↑
div              ↓                        ↑
  目标元素 (target)
```

### 2.2 监听捕获与冒泡

在 `addEventListener` 中，第三个参数可以控制监听器在哪个阶段执行：

- `false`（默认）：在冒泡阶段执行。
- `true`：在捕获阶段执行。

```javascript
element.addEventListener('click', () => {
  console.log('冒泡阶段执行');
}, false);

element.addEventListener('click', () => {
  console.log('捕获阶段执行');
}, true);
```

**注意**：并非所有事件都支持冒泡（如 `focus`、`blur`、`load` 等），但绝大多数用户交互事件都支持。

### 2.3 示例：观察事件流

```html
<div id="parent">
  <button id="child">点击我</button>
</div>
```

```javascript
document.getElementById('parent').addEventListener('click', () => {
  console.log('父元素捕获', '捕获阶段');
}, true);
document.getElementById('parent').addEventListener('click', () => {
  console.log('父元素冒泡');
}, false);

document.getElementById('child').addEventListener('click', () => {
  console.log('目标元素（目标阶段）');
});

// 点击按钮后，输出顺序：
// 父元素捕获
// 目标元素（目标阶段）
// 父元素冒泡
```

---

## 3. 事件监听

### 3.1 注册事件监听器

#### `addEventListener(type, listener, options)`

最推荐的方式，可以为一个事件注册多个监听器，并控制执行阶段。

- `type`：事件类型字符串，如 `'click'`、`'keydown'`。
- `listener`：回调函数，接受一个 `event` 对象作为参数。
- `options`（可选）：可以是布尔值（表示是否在捕获阶段执行）或一个配置对象：
  - `capture`：布尔值，是否在捕获阶段执行（默认 `false`）。
  - `once`：布尔值，监听器最多执行一次，执行后自动移除。
  - `passive`：布尔值，表示监听器永远不会调用 `preventDefault()`，可提升滚动性能。

```javascript
const btn = document.getElementById('btn');

btn.addEventListener('click', function(event) {
  console.log('按钮被点击');
});

// 使用 once 选项，只触发一次
btn.addEventListener('click', () => {
  console.log('这只会执行一次');
}, { once: true });

// 使用 passive 优化滚动
document.addEventListener('touchstart', (e) => {
  // 不调用 preventDefault
}, { passive: true });
```

#### 使用 HTML 属性（不推荐）

```html
<button onclick="alert('点击')">点我</button>
```

这种方式会创建全局函数，且只能绑定一个监听器，不利于维护。

#### 使用 DOM 元素属性（旧方式）

```javascript
btn.onclick = function(event) {
  console.log('点击');
};
btn.onclick = null; // 移除
```

这种方式只能绑定一个监听器，后面的赋值会覆盖前面的。

### 3.2 移除事件监听器

使用 `removeEventListener(type, listener, options)`，需要传入与添加时相同的函数引用（不能是匿名函数）。

```javascript
function handler(event) {
  console.log('点击');
}
btn.addEventListener('click', handler);
// 后续移除
btn.removeEventListener('click', handler);
```

### 3.3 事件监听器中的 `this`

在普通函数中，`this` 指向绑定事件的元素。在箭头函数中，`this` 继承自外部作用域。

```javascript
btn.addEventListener('click', function() {
  console.log(this === btn); // true
});
btn.addEventListener('click', () => {
  console.log(this === window); // true（如果外层是全局）
});
```

---

## 4. 事件对象

每个事件监听器都会收到一个事件对象（通常命名为 `event` 或 `e`），它包含了事件的详细信息和控制方法。

### 4.1 常用属性

| 属性               | 描述                                           |
| ------------------ | ---------------------------------------------- |
| `type`             | 事件类型（如 `'click'`）。                     |
| `target`           | 触发事件的原始元素（在事件流中始终指向目标）。 |
| `currentTarget`    | 当前正在处理事件的元素（即监听器绑定的元素）。 |
| `eventPhase`       | 当前事件阶段（1:捕获，2:目标，3:冒泡）。       |
| `bubbles`          | 布尔值，表示事件是否会冒泡。                   |
| `cancelable`       | 布尔值，表示是否可以取消默认行为。             |
| `defaultPrevented` | 布尔值，表示是否已调用 `preventDefault()`。    |
| `timestamp`        | 事件发生的时间戳。                             |

### 4.2 常用方法

| 方法                         | 描述                                                     |
| ---------------------------- | -------------------------------------------------------- |
| `preventDefault()`           | 取消事件的默认行为（如点击链接不跳转）。                 |
| `stopPropagation()`          | 阻止事件继续传播（既阻止捕获也阻止冒泡）。               |
| `stopImmediatePropagation()` | 阻止事件传播，并阻止当前元素上其他相同事件的监听器执行。 |

### 4.3 不同类型事件对象的特有属性

不同事件类型的事件对象可能包含额外属性，例如：

- **鼠标事件**：`clientX`、`clientY`、`button`、`altKey` 等。
- **键盘事件**：`key`、`code`、`ctrlKey`、`shiftKey` 等。
- **触摸事件**：`touches`、`targetTouches`、`changedTouches` 等。
- **焦点事件**：`relatedTarget`（焦点移出/移入的相关元素）。

---

## 5. 常用事件类型

### 5.1 鼠标事件

| 事件          | 描述                         |
| ------------- | ---------------------------- |
| `click`       | 点击元素（鼠标按下并抬起）。 |
| `dblclick`    | 双击元素。                   |
| `mousedown`   | 鼠标按下。                   |
| `mouseup`     | 鼠标抬起。                   |
| `mousemove`   | 鼠标在元素上移动。           |
| `mouseover`   | 鼠标进入元素（支持冒泡）。   |
| `mouseout`    | 鼠标离开元素（支持冒泡）。   |
| `mouseenter`  | 鼠标进入元素（不冒泡）。     |
| `mouseleave`  | 鼠标离开元素（不冒泡）。     |
| `contextmenu` | 右键菜单打开前触发。         |

**示例**：

```javascript
element.addEventListener('mousemove', (e) => {
  console.log(`鼠标位置: (${e.clientX}, ${e.clientY})`);
});
```

### 5.2 键盘事件

| 事件       | 描述                                     |
| ---------- | ---------------------------------------- |
| `keydown`  | 按下任意键（包括功能键）。               |
| `keypress` | 按下字符键（已废弃，建议用 `keydown`）。 |
| `keyup`    | 释放按键。                               |

```javascript
document.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    console.log('回车键被按下');
  }
  if (e.ctrlKey && e.key === 's') {
    e.preventDefault(); // 阻止默认保存行为
    console.log('捕获 Ctrl+S');
  }
});
```

### 5.3 表单事件

| 事件       | 描述                                                                     |
| ---------- | ------------------------------------------------------------------------ |
| `submit`   | 表单提交时触发（在 `<form>` 上监听）。                                   |
| `reset`    | 表单重置时触发。                                                         |
| `focus`    | 元素获得焦点（不冒泡）。                                                 |
| `blur`     | 元素失去焦点（不冒泡）。                                                 |
| `focusin`  | 元素获得焦点（冒泡）。                                                   |
| `focusout` | 元素失去焦点（冒泡）。                                                   |
| `input`    | 输入值变化时触发（实时，如 `<input>`、`<textarea>`）。                   |
| `change`   | 元素值改变且失去焦点时触发（如 `<select>`、`<input type="checkbox">`）。 |

```javascript
const input = document.querySelector('input');
input.addEventListener('input', (e) => {
  console.log('当前值:', e.target.value);
});
form.addEventListener('submit', (e) => {
  e.preventDefault(); // 阻止表单提交
  console.log('验证表单...');
});
```

### 5.4 触摸事件（移动端）

| 事件          | 描述                   |
| ------------- | ---------------------- |
| `touchstart`  | 手指触摸屏幕。         |
| `touchmove`   | 手指在屏幕上滑动。     |
| `touchend`    | 手指离开屏幕。         |
| `touchcancel` | 触摸被中断（如来电）。 |

触摸事件对象包含 `touches`（当前所有触摸点）、`targetTouches`、`changedTouches` 等列表。

### 5.5 焦点事件

除了 `focus`/`blur`，还有 `focusin`/`focusout`（冒泡版本）。`relatedTarget` 可获取相关元素。

### 5.6 滚动事件

`scroll` 事件可在 `window` 或可滚动元素上监听。注意滚动事件触发频率高，应避免执行复杂操作。

```javascript
window.addEventListener('scroll', () => {
  console.log('滚动位置:', window.scrollY);
});
```

### 5.7 资源事件

| 事件     | 描述                       |
| -------- | -------------------------- |
| `load`   | 资源及其依赖资源加载完成。 |
| `error`  | 资源加载失败。             |
| `abort`  | 资源加载被中止。           |
| `unload` | 页面卸载（即将离开）。     |

### 5.8 其他事件

- **剪贴板事件**：`cut`、`copy`、`paste`
- **拖拽事件**：`dragstart`、`drag`、`dragenter`、`dragover`、`drop`、`dragend`
- **动画事件**：`animationstart`、`animationend`、`animationiteration`
- **过渡事件**：`transitionstart`、`transitionend`

---

## 6. 事件委托

### 6.1 什么是事件委托？

事件委托利用事件冒泡，将事件监听器绑定到父元素上，用于处理来自多个子元素的事件。这对于动态添加的子元素尤其有用，无需为新元素重新绑定事件。

### 6.2 示例

```html
<ul id="todo-list">
  <li>任务1 <button class="delete">删除</button></li>
  <li>任务2 <button class="delete">删除</button></li>
  <li>任务3 <button class="delete">删除</button></li>
</ul>
```

传统方式需要为每个按钮绑定事件，效率低且无法处理动态新增的按钮。

使用事件委托：

```javascript
document.getElementById('todo-list').addEventListener('click', (e) => {
  if (e.target.classList.contains('delete')) {
    const li = e.target.closest('li');
    li.remove();
    console.log('删除任务:', li.textContent.trim());
  }
});
```

### 6.3 优点

- 减少事件监听器数量，节省内存。
- 动态添加的子元素自动继承事件处理。
- 代码更简洁。

### 6.4 注意事项

- 需要确保事件确实冒泡到父元素（某些事件不冒泡）。
- 通过 `e.target` 判断实际目标，可能要考虑点击的是子元素内部的情况（如按钮内的图标）。

---

## 7. 自定义事件与派发

除了浏览器内置事件，我们还可以创建并派发自定义事件，用于组件间通信或解耦。

### 7.1 创建自定义事件

使用 `CustomEvent` 构造函数，可以传递 `detail` 属性携带额外数据。

```javascript
const myEvent = new CustomEvent('userLogin', {
  detail: { username: 'Alice', time: Date.now() },
  bubbles: true,   // 是否冒泡
  cancelable: true // 是否可取消
});
```

### 7.2 派发事件

使用 `element.dispatchEvent(event)` 触发事件。

```javascript
const userCard = document.getElementById('user-card');
userCard.addEventListener('userLogin', (e) => {
  console.log('用户登录:', e.detail);
});
userCard.dispatchEvent(myEvent);
```

### 7.3 内置事件也可以手动派发

可以手动触发内置事件（如 `click`）：

```javascript
btn.dispatchEvent(new Event('click', { bubbles: true }));
```

---

## 8. 阻止默认行为与传播

### 8.1 阻止默认行为

调用 `event.preventDefault()` 可以阻止浏览器对事件的默认动作，例如：

- 点击链接不跳转。
- 在表单提交时不刷新页面。
- 按下右键时不显示上下文菜单。

```javascript
link.addEventListener('click', (e) => {
  e.preventDefault();
  console.log('链接被点击但不会跳转');
});
```

检查 `event.cancelable` 可以知道默认行为是否可被阻止。

### 8.2 阻止事件传播

- `event.stopPropagation()`：阻止事件在捕获/冒泡阶段继续传播。
- `event.stopImmediatePropagation()`：阻止传播，并阻止当前元素上其他相同事件的监听器执行。

```javascript
parent.addEventListener('click', () => console.log('父元素'));
child.addEventListener('click', (e) => {
  e.stopPropagation(); // 事件不会到达父元素
  console.log('子元素');
});
```

---

## 9. 事件性能与优化

### 9.1 使用 `passive` 提升滚动性能

在移动端，`touchstart` 和 `touchmove` 事件中调用 `preventDefault()` 会阻止滚动，浏览器必须等待监听器执行才能判断是否滚动，导致卡顿。设置 `passive: true` 告诉浏览器监听器不会调用 `preventDefault()`，从而立即执行滚动。

```javascript
document.addEventListener('touchstart', handler, { passive: true });
```

### 9.2 避免在事件监听器中执行耗时操作

事件监听器应尽量轻量，耗时操作（如复杂计算、DOM 操作）可能导致界面卡顿。可以考虑：

- 使用 `requestAnimationFrame` 延迟更新。
- 将任务拆分为微任务或宏任务（`setTimeout`）。
- 使用 `debounce` 或 `throttle` 限制高频事件（如 `scroll`、`resize`）的处理频率。

```javascript
// 使用 throttle 限制滚动事件处理频率
let ticking = false;
window.addEventListener('scroll', () => {
  if (!ticking) {
    window.requestAnimationFrame(() => {
      // 实际处理逻辑
      ticking = false;
    });
    ticking = true;
  }
});
```

### 9.3 及时移除不需要的事件监听器

当元素被移除时，其上的监听器应该被移除，否则可能造成内存泄漏。使用 `removeEventListener` 或利用 `{ once: true }` 选项。

---

## 10. 最佳实践

1. **使用 `addEventListener`，避免内联属性**  
   可维护性更好，支持多监听器，可控制捕获/冒泡。

2. **合理使用事件委托**  
   对于动态元素或大量相似元素，优先考虑事件委托。

3. **命名监听器函数以便移除**  
   不要使用匿名函数，除非你确定不需要移除。

4. **检查 `target` 而非 `currentTarget`**  
   在事件委托中，通过 `e.target` 确定实际触发元素。

5. **避免滥用 `stopPropagation()`**  
   过度阻止传播可能导致其他依赖冒泡的功能失效（如分析脚本）。

6. **使用 `passive` 提高滚动性能**  
   对于 `touchstart`、`touchmove`、`wheel` 等事件，若无需阻止默认行为，设置 `passive: true`。

7. **考虑事件名称冲突**  
   自定义事件名避免与未来标准事件重名，可使用命名空间（如 `myapp:userlogin`）。

8. **测试不同设备上的事件行为**  
   特别是移动端触摸事件与鼠标事件的差异。

---

## 小结

事件系统是浏览器交互的基石，理解事件流、事件对象、事件类型以及事件委托，能够让你构建出响应迅速、可维护的 Web 应用。本章详细介绍了：

- 事件流的三个阶段：捕获、目标、冒泡。
- 事件监听器的注册与移除，包括现代 `options` 参数。
- 事件对象的常用属性和方法。
- 各类常见事件类型及其特点。
- 事件委托的原理与应用。
- 自定义事件的创建与派发。
- 如何阻止默认行为和传播。
- 性能优化与最佳实践。

掌握这些知识，你将能优雅地处理用户交互，实现复杂的交互逻辑。下一节我们将学习**浏览器存储**相关的内容，如 Cookie、Web Storage、IndexedDB 等。
