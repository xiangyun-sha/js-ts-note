# 生态系统 · 服务器端 · Node.js 核心模块

[TOC]

---

Node.js 的核心模块是编译进二进制文件中的内置模块，它们提供了 JavaScript 在服务器端运行所需的基础能力。这些模块无需通过 npm 安装，只需使用 `require` 或 `import` 即可引入。掌握这些核心模块是使用 Node.js 进行后端开发的基础。

---

## 1. 核心模块概述

Node.js 的架构分为三层：

- **底层系统依赖**：包括 V8 引擎、libuv（事件循环）、OpenSSL（加密）、zlib（压缩）等
- **C++ 绑定层**：将底层能力暴露给 JavaScript
- **JavaScript 核心模块层**：提供开发者直接使用的高层 API

核心模块正是位于最上层，为开发者提供了文件操作、网络通信、路径处理、加密等功能。

---

## 2. 核心模块分类详解

### 2.1 文件系统模块 (fs)

`fs` 模块用于与文件系统进行交互，支持读写文件、创建目录、删除文件等操作。

**常用方法**：

```javascript
const fs = require('fs');

// 异步读取文件
fs.readFile('file.txt', 'utf8', (err, data) => {
  if (err) throw err;
  console.log(data);
});

// 同步写入文件
fs.writeFileSync('output.txt', 'Hello Node.js');

// 创建目录
fs.mkdir('new-dir', (err) => {
  if (err) throw err;
});
```

**应用场景**：日志记录系统、配置文件读写、数据导入导出工具。

### 2.2 HTTP 与 HTTPS 模块

`http` 和 `https` 模块用于创建 Web 服务器和发起 HTTP 请求。

**创建 HTTP 服务器**：

```javascript
const http = require('http');

const server = http.createServer((req, res) => {
  res.writeHead(200, { 'Content-Type': 'text/plain' });
  res.end('Hello World\n');
});

server.listen(3000, () => {
  console.log('Server running at http://localhost:3000/');
});
```

**应用场景**：构建 RESTful API、代理服务器、Web 应用后端。

### 2.3 路径处理模块 (path)

`path` 模块提供跨平台的文件路径处理工具，自动处理不同操作系统（Windows 与 POSIX）的路径分隔符差异。

**常用方法**：

```javascript
const path = require('path');

// 路径拼接
const fullPath = path.join(__dirname, 'files', 'data.txt');

// 获取文件信息
console.log(path.basename('/foo/bar/baz.txt')); // 'baz.txt'
console.log(path.extname('image.jpg'));         // '.jpg'
console.log(path.parse('/home/user/file.js'));  // 返回路径对象

// 判断是否为绝对路径
console.log(path.isAbsolute('/绝对/路径'));     // true
```

### 2.4 操作系统模块 (os)

`os` 模块提供与操作系统相关的信息和实用函数。

**常用方法**：

```javascript
const os = require('os');

console.log('平台:', os.platform());      // 'darwin' (macOS), 'win32' (Windows)
console.log('架构:', os.arch());          // 'x64'
console.log('CPU:', os.cpus());           // CPU 核心信息
console.log('内存:', os.totalmem() / 1024 / 1024 / 1024, 'GB');
console.log('主机名:', os.hostname());
console.log('网络接口:', os.networkInterfaces());
```

### 2.5 事件模块 (events)

`events` 模块是 Node.js 事件驱动体系的核心，提供了 `EventEmitter` 类，用于创建和处理自定义事件。

```javascript
const EventEmitter = require('events');

class MyEmitter extends EventEmitter {}
const myEmitter = new MyEmitter();

// 监听事件
myEmitter.on('event', () => {
  console.log('事件触发！');
});

// 触发事件
myEmitter.emit('event');
```

**应用场景**：用户操作响应、后台任务状态通知、异步事件驱动机制。

### 2.6 流模块 (stream)

`stream` 模块用于处理流式数据，可以读取和写入可流式的数据。

```javascript
const fs = require('fs');

// 创建读取流
const readStream = fs.createReadStream('large-file.txt');
const writeStream = fs.createWriteStream('output.txt');

// 管道传输
readStream.pipe(writeStream);

readStream.on('data', (chunk) => {
  console.log(`接收到 ${chunk.length} 字节数据`);
});
```

**应用场景**：处理大文件、视频流、网络数据传输。

### 2.7 加密模块 (crypto)

`crypto` 模块提供加密和解密功能，包括哈希算法、对称加密和非对称加密。

```javascript
const crypto = require('crypto');

// 创建哈希
const hash = crypto.createHash('sha256');
hash.update('要加密的数据');
console.log(hash.digest('hex')); // 16进制输出

// 随机数生成
crypto.randomBytes(16, (err, buffer) => {
  console.log(buffer.toString('hex'));
});
```

### 2.8 URL 与查询字符串模块

`url` 和 `querystring` 模块用于处理 URL 和查询字符串。

```javascript
const url = require('url');
const querystring = require('querystring');

// 解析 URL
const parsedUrl = new URL('https://example.com:8080/path?name=张三&age=25');
console.log(parsedUrl.hostname); // 'example.com'
console.log(parsedUrl.searchParams.get('name')); // '张三'

// 解析查询字符串
const params = querystring.parse('foo=bar&baz=qux');
console.log(params); // { foo: 'bar', baz: 'qux' }
```

### 2.9 进程模块 (process)

`process` 对象虽然不是核心模块（无需 require），但它提供关于当前 Node.js 进程的信息和控制能力。

```javascript
// 命令行参数
console.log(process.argv);

// 环境变量
console.log(process.env.NODE_ENV);

// 当前工作目录
console.log(process.cwd());

// 退出进程
process.exit(0);

// 监听进程退出
process.on('exit', (code) => {
  console.log(`进程退出，退出码: ${code}`);
});
```

### 2.10 其他重要核心模块

| 模块            | 描述           | 主要用途                       |
| --------------- | -------------- | ------------------------------ |
| `child_process` | 创建子进程     | 执行系统命令、多进程处理       |
| `cluster`       | 多核集群       | 充分利用多核 CPU               |
| `dns`           | 域名解析       | DNS 查询、域名解析             |
| `net`           | 网络套接字     | TCP 服务器和客户端             |
| `readline`      | 逐行读取       | 交互式命令行工具               |
| `assert`        | 断言测试       | 编写测试、验证条件             |
| `buffer`        | 二进制数据处理 | TCP 流、文件操作中的二进制数据 |
| `util`          | 实用工具       | 类型判断、格式化等辅助函数     |
| `zlib`          | 压缩/解压      | gzip、deflate 压缩             |
| `timers`        | 定时器         | `setTimeout`、`setInterval` 等 |

---

## 3. 模块加载机制

Node.js 使用 CommonJS 模块系统（默认）并支持 ES Modules。

### 3.1 CommonJS 规范

```javascript
// 导出
module.exports = { myFunction };
// 或
exports.myFunction = myFunction;

// 导入
const myModule = require('./my-module');
```

### 3.2 ES Modules 规范

可通过 `.mjs` 扩展名或在 `package.json` 中设置 `"type": "module"` 启用：

```javascript
// 导出
export function myFunction() {}
export default myFunction;

// 导入
import myFunction, { otherFunction } from './my-module.mjs';
```

### 3.3 加载流程

1. 调用 `Module._load` 方法
2. 检查缓存 `Module._cache`
3. 创建新 `Module` 实例
4. 保存到缓存
5. 执行模块代码
6. 返回 `exports` 对象

---

## 4. 最佳实践

1. **选择异步 API**：优先使用异步方法（回调、Promise、async/await），避免阻塞事件循环。

2. **路径处理**：始终使用 `path.join()` 或 `path.resolve()` 处理路径，避免手动拼接。

3. **错误处理**：异步操作必须处理错误，同步操作应使用 try/catch：

   ```javascript
   fs.readFile('file.txt', (err, data) => {
     if (err) {
       console.error('读取失败:', err);
       return;
     }
     // 处理数据
   });
   ```

4. **流式处理大文件**：处理大文件时使用流而非一次性读取。

5. **环境变量管理**：使用 `process.env` 读取配置，配合 `.env` 文件。

6. **模块化设计**：遵循单一职责原则，每个模块只做一件事。

---

## 小结

Node.js 核心模块为服务器端 JavaScript 开发提供了坚实的能力基础。本章介绍了：

- **文件系统**（fs）：文件和目录操作
- **网络通信**（http、https、net）：服务器和客户端
- **路径处理**（path）：跨平台路径工具
- **操作系统信息**（os）：系统资源监控
- **事件驱动**（events）：自定义事件和监听器
- **流处理**（stream）：高效处理大数据
- **加密**（crypto）：安全功能
- **进程控制**（process）：运行时信息
- **其他实用模块**：url、querystring、child_process 等

掌握这些核心模块，你将能够构建从简单脚本到复杂 Web 应用的各种 Node.js 程序。在实际开发中，核心模块通常与第三方模块（如 Express、Mongoose）配合使用，以提升开发效率。
