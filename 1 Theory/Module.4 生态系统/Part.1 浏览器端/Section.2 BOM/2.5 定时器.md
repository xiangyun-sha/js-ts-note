# 定时器

[TOC]

---

定时器是浏览器环境中用于延迟执行或周期性执行代码的核心机制。它们基于事件循环工作，允许开发者将函数的执行调度到未来的某个时刻。浏览器提供了两组主要的定时器 API：传统定时器（`setTimeout`/`setInterval`）以及更现代的动画帧（`requestAnimationFrame`）和空闲回调（`requestIdleCallback`）。本章将全面介绍这些定时器的用法、工作原理、适用场景及最佳实践。

---

## 1. 传统定时器：setTimeout 与 setInterval

### 1.1 setTimeout

**`setTimeout(callback, delay, ...args)`**：在指定的延迟（毫秒）后，将回调函数添加到任务队列中等待执行。它返回一个整数类型的定时器标识符，可用于取消该定时器。

```javascript
const timerId = setTimeout(() => {
  console.log('延迟 1000ms 后执行');
}, 1000);

// 取消定时器
clearTimeout(timerId);
```

- **`callback`**：要执行的函数。可以是一个函数引用，也可以直接传入函数体。
- **`delay`**：延迟的毫秒数。实际延迟只会大于或等于这个值，不会小于（受事件循环影响）。如果省略，默认为 0。
- **`...args`**：可选的额外参数，在调用 `callback` 时会作为参数传递（IE9 及以下不支持，但现代浏览器都支持）。

### 1.2 setInterval

**`setInterval(callback, interval, ...args)`**：每隔指定的间隔（毫秒）重复执行回调函数。它同样返回一个整数标识符。

```javascript
const intervalId = setInterval(() => {
  console.log('每隔 1000ms 执行一次');
}, 1000);

// 取消间隔
clearInterval(intervalId);
```

**重要警告**：`setInterval` 并不保证两次执行之间的间隔精确等于 `interval`。如果回调执行时间很长，或者浏览器有其他任务阻塞，后续调用可能会延迟或累积（例如，回调执行时间超过间隔时间，则可能连续执行）。通常，使用递归的 `setTimeout` 替代 `setInterval` 更为可靠。

### 1.3 定时器标识符与清除

`setTimeout` 和 `setInterval` 返回的标识符是一个数字（在浏览器中通常是递增的整数）。可以使用对应的清除函数取消尚未执行或正在等待的定时器。

```javascript
const id = setTimeout(...);
clearTimeout(id);   // 取消 setTimeout

const id2 = setInterval(...);
clearInterval(id2); // 取消 setInterval
```

**注意**：在浏览器中，`clearTimeout` 和 `clearInterval` 可以混用（即用 `clearTimeout` 清除 `setInterval` 也是有效的，反之亦然）。但为了代码清晰，建议保持对应使用。

### 1.4 延迟时间不精确的原因

定时器的延迟时间并不是精确的，原因在于：

- **事件循环机制**：`setTimeout` 的回调必须等待当前执行栈清空、微任务队列清空后，才会从宏任务队列中取出执行。
- **浏览器最小延迟限制**：嵌套的 `setTimeout` 超过 5 层后，最小延迟会被强制设为 4ms（HTML 规范规定）。
- **节流与后台标签页**：当页面处于非激活状态时，浏览器可能会节流定时器以节省资源，将最小延迟提升到 1000ms 甚至更高。

因此，`setTimeout(fn, 0)` 并不能真正“立即执行”，而是将任务排入队列，尽快执行（在当前执行栈和微任务之后）。

### 1.5 递归 setTimeout 与 setInterval 对比

`setInterval` 可能导致回调堆积，例如：

```javascript
setInterval(() => {
  // 假设这个任务需要 200ms
  heavyTask();
}, 100);
```

如果 `heavyTask` 执行时间超过 100ms，那么下一次调用会在任务完成后立即发生（如果队列中没有堆积），但无法保证准确间隔。更糟糕的是，如果回调被阻塞多次，浏览器可能会连续执行多次回调，造成“追赶”现象。

使用递归 `setTimeout` 可以确保每次执行完成后才设置下一次调用，从而避免累积：

```javascript
function repeat() {
  heavyTask();
  setTimeout(repeat, 100);
}
repeat();
```

这种方式能够保证每次间隔从上次任务结束开始计时，而非固定间隔。适合对间隔要求不那么严格且需要避免并发执行的场景。

---

## 2. 动画帧：requestAnimationFrame

`requestAnimationFrame(callback)` 是专门为动画设计的定时器。它告诉浏览器在下一次重绘之前调用指定的回调函数，通常与屏幕刷新率同步（一般是 60Hz，即每秒调用 60 次）。

### 2.1 基本用法

```javascript
let start;
function step(timestamp) {
  if (start === undefined) start = timestamp;
  const progress = timestamp - start;
  element.style.transform = `translateX(${Math.min(progress / 5, 200)}px)`;
  if (progress < 5000) {
    requestAnimationFrame(step);
  }
}
requestAnimationFrame(step);
```

- `callback` 接收一个参数 `timestamp`，表示回调被调用的当前时间（`performance.now()` 的高精度时间戳）。
- 返回值是一个整数 ID，可通过 `cancelAnimationFrame(id)` 取消。

### 2.2 优势

- **与浏览器刷新同步**：保证动画平滑，避免掉帧。
- **后台标签页暂停**：当页面不可见时，`requestAnimationFrame` 会暂停，节省 CPU 资源。
- **自动节流**：显示器刷新频率决定了回调的执行频率，通常为 60fps，但高刷新率显示器可能达到 120fps。

### 2.3 与 setTimeout 的对比

| 特性     | `setTimeout` 动画          | `requestAnimationFrame` 动画 |
| -------- | -------------------------- | ---------------------------- |
| 执行时机 | 任意时刻（取决于事件循环） | 下一次重绘前，与屏幕刷新同步 |
| 平滑度   | 可能产生卡顿、撕裂         | 平滑，与刷新率匹配           |
| 后台行为 | 可能继续执行（可被节流）   | 自动暂停，恢复时继续         |
| 节流     | 可能因事件循环阻塞         | 自动协调，避免过度绘制       |
| 适合场景 | 一般延迟任务               | 视觉变化动画                 |

---

## 3. 空闲回调：requestIdleCallback

`requestIdleCallback(callback, options)` 允许开发者在浏览器空闲时段执行低优先级任务，例如分析、预加载、非交互性日志上报等。回调函数会在浏览器主线程空闲时被调用，不会影响关键操作（如动画、输入响应）。

### 3.1 基本用法

```javascript
requestIdleCallback(myTask, { timeout: 2000 });

function myTask(deadline) {
  // deadline 对象包含两个方法：
  // deadline.timeRemaining()：返回当前空闲剩余时间（毫秒）
  // deadline.didTimeout：是否因超时而执行

  while (deadline.timeRemaining() > 0 && tasks.length > 0) {
    performTask(tasks.shift());
  }
  if (tasks.length > 0) {
    requestIdleCallback(myTask);
  }
}
```

- **`options.timeout`**：如果指定了超时时间，且在该时间内回调未被调用，它将在下一次空闲时（或强制）被尽快执行。
- 返回值是一个 ID，可通过 `cancelIdleCallback(id)` 取消。

### 3.2 适用场景

- 上报统计数据、日志。
- 预加载后续页面资源。
- 执行非关键的 DOM 操作或数据处理。

### 3.3 注意事项

- 支持度：现代浏览器支持良好，但 Safari 不支持（截至 2023 年）。需要使用 `setTimeout` 降级。
- 空闲回调不应该执行时间过长的任务，应根据 `deadline.timeRemaining()` 判断剩余时间，分片处理。
- 永远不要用于更新 UI 或响应用户交互的关键任务。

---

## 4. 实际应用示例

### 4.1 防抖与节流

定时器常用于实现防抖（debounce）和节流（throttle）。

**防抖**：在事件被触发 n 秒后再执行回调，如果在此期间被再次触发，则重新计时。

```javascript
function debounce(fn, delay) {
  let timer = null;
  return function(...args) {
    clearTimeout(timer);
    timer = setTimeout(() => fn.apply(this, args), delay);
  };
}
```

**节流**：规定一个单位时间内，只能触发一次函数。

```javascript
function throttle(fn, interval) {
  let lastTime = 0;
  return function(...args) {
    const now = Date.now();
    if (now - lastTime >= interval) {
      lastTime = now;
      fn.apply(this, args);
    }
  };
}
```

### 4.2 倒计时

使用 `setInterval` 实现倒计时，注意清除定时器。

```javascript
function countdown(seconds, onTick, onComplete) {
  let remaining = seconds;
  const interval = setInterval(() => {
    remaining--;
    onTick(remaining);
    if (remaining <= 0) {
      clearInterval(interval);
      onComplete();
    }
  }, 1000);
}
```

### 4.3 使用 requestAnimationFrame 实现平滑滚动

```javascript
function smoothScrollTo(targetY, duration = 500) {
  const startY = window.scrollY;
  const distance = targetY - startY;
  const startTime = performance.now();

  function step(now) {
    const elapsed = now - startTime;
    const progress = Math.min(elapsed / duration, 1);
    window.scrollTo(0, startY + distance * progress);
    if (progress < 1) {
      requestAnimationFrame(step);
    }
  }
  requestAnimationFrame(step);
}
```

### 4.4 使用 requestIdleCallback 上报性能数据

```javascript
function reportPerfData() {
  requestIdleCallback(() => {
    const data = collectPerformanceMetrics();
    if (navigator.sendBeacon) {
      navigator.sendBeacon('/analytics', JSON.stringify(data));
    } else {
      fetch('/analytics', { method: 'POST', body: JSON.stringify(data) });
    }
  }, { timeout: 3000 });
}
```

---

## 5. 注意事项与最佳实践

### 5.1 内存泄漏

定时器如果不及时清除，可能会导致回调函数及其引用的对象无法被垃圾回收，从而造成内存泄漏。

```javascript
// 潜在泄漏
function start() {
  setInterval(() => {
    // 引用了 DOM 元素
    const el = document.getElementById('test');
    el.innerHTML = Date.now();
  }, 1000);
}
// 如果页面卸载前没有清除，定时器依然存在，el 无法被回收
```

**解决方案**：在组件卸载或不再需要时，清除所有定时器。

### 5.2 this 绑定问题

定时器的回调中，`this` 默认指向全局对象（浏览器中为 `window`）或 `undefined`（严格模式）。如果希望保留 `this`，可以使用箭头函数或 `bind`。

```javascript
function MyComponent() {
  this.value = 42;
  setTimeout(function() {
    console.log(this.value); // undefined
  }, 100);

  setTimeout(() => {
    console.log(this.value); // 42
  }, 100);
}
```

### 5.3 大量定时器的性能

创建大量的定时器（例如数千个）会消耗内存和调度资源。应避免滥用。如果需要处理大量延迟任务，可以考虑使用单一定时器统一调度。

### 5.4 精确延迟需求

对于需要精确计时的场景（如倒计时），应基于 Date 或 performance.now 计算剩余时间，而不是假设定时器会精确触发。

```javascript
function accurateTimer(duration, onTick) {
  const start = Date.now();
  function tick() {
    const elapsed = Date.now() - start;
    const remaining = Math.max(0, duration - elapsed);
    onTick(remaining);
    if (remaining > 0) {
      setTimeout(tick, 10); // 使用短间隔提高精度
    }
  }
  tick();
}
```

### 5.5 取消定时器的最佳时机

- 在 `setTimeout` 回调执行前，如果不再需要，应该调用 `clearTimeout`。
- 对于单页应用，在路由切换或组件卸载时清除相关定时器。
- 使用 `setInterval` 时，确保在适当时候（如条件满足）调用 `clearInterval`。

---

## 6. 小结

定时器是浏览器异步编程的重要工具。本章介绍了：

- **`setTimeout` / `setInterval`**：基础延迟和周期性执行，需注意不精确和内存管理。
- **`requestAnimationFrame`**：动画专用，与屏幕刷新同步，性能更优。
- **`requestIdleCallback`**：利用空闲时间执行低优先级任务。
- 实际应用示例（防抖、节流、倒计时、平滑滚动）。
- 注意事项：内存泄漏、this 绑定、大量定时器性能。

选择合适的定时器不仅能提高代码性能，还能提升用户体验。在开发中，应根据任务类型和对时机的要求，灵活运用这些 API。
