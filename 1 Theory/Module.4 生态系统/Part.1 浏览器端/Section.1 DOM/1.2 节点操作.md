# 节点操作

[TOC]

---

在掌握了 DOM 树的基本结构和节点类型之后，我们需要学会如何**操作**这些节点——获取它们、遍历它们、创建新节点、插入到文档中、删除现有节点、修改属性与样式，以及控制滚动行为。这些操作是动态页面交互的核心。本章将全面介绍节点操作的各个方面，提供丰富的示例和最佳实践。

---

## 1. 获取节点

获取节点是操作的第一步。浏览器提供了多种 API 来获取单个或多个节点。

### 1.1 通过 id 获取

`document.getElementById(id)` 是最快的获取方式，返回匹配 id 的元素节点（`Element`），若无则返回 `null`。

```javascript
const header = document.getElementById('header');
```

### 1.2 通过标签名获取

`document.getElementsByTagName(tagName)` 返回一个动态的 `HTMLCollection`，包含所有指定标签名的元素。

```javascript
const paragraphs = document.getElementsByTagName('p');
// 遍历
for (let i = 0; i < paragraphs.length; i++) {
  console.log(paragraphs[i].textContent);
}
```

### 1.3 通过类名获取

`document.getElementsByClassName(className)` 返回动态的 `HTMLCollection`，包含所有拥有指定类名的元素。

```javascript
const items = document.getElementsByClassName('item');
```

### 1.4 通过 CSS 选择器获取（最灵活）

- **`document.querySelector(selector)`**：返回匹配指定选择器的**第一个**元素，若无则返回 `null`。
- **`document.querySelectorAll(selector)`**：返回一个静态的 `NodeList`，包含所有匹配的元素。

```javascript
const firstButton = document.querySelector('.btn.primary');
const allButtons = document.querySelectorAll('button');
```

`querySelectorAll` 返回的 `NodeList` 是静态的，不会随 DOM 变化而自动更新。

### 1.5 通过节点关系获取

在已获取的节点基础上，可以通过关系属性获取其他节点（见“遍历与关系”一节）。

### 1.6 获取特殊节点

- **根元素**：`document.documentElement`（`<html>`）
- **主体**：`document.body`（`<body>`）
- **头部**：`document.head`（`<head>`）
- **当前焦点元素**：`document.activeElement`

---

## 2. 节点遍历与关系

一旦拥有一个节点，你可以通过属性访问其周围的节点。关系属性分为**所有节点**和**仅元素节点**两类。

### 2.1 所有节点关系

| 属性              | 描述                                          |
| ----------------- | --------------------------------------------- |
| `parentNode`      | 父节点（可能是元素、document 等）。           |
| `childNodes`      | 所有子节点的 `NodeList`（包含文本、注释等）。 |
| `firstChild`      | 第一个子节点。                                |
| `lastChild`       | 最后一个子节点。                              |
| `previousSibling` | 前一个兄弟节点。                              |
| `nextSibling`     | 后一个兄弟节点。                              |

```javascript
const ul = document.querySelector('ul');
const firstLi = ul.firstChild; // 可能是文本节点（换行），需注意
const parent = ul.parentNode;
```

### 2.2 仅元素节点关系

| 属性                     | 描述                                            |
| ------------------------ | ----------------------------------------------- |
| `parentElement`          | 父元素节点（如果父节点不是元素，则为 `null`）。 |
| `children`               | 所有**元素**子节点的 `HTMLCollection`。         |
| `firstElementChild`      | 第一个元素子节点。                              |
| `lastElementChild`       | 最后一个元素子节点。                            |
| `previousElementSibling` | 前一个元素兄弟节点。                            |
| `nextElementSibling`     | 后一个元素兄弟节点。                            |

```javascript
const listItems = ul.children; // 只包含 <li>
const secondItem = listItems[1];
const prev = secondItem.previousElementSibling; // 第一个 <li>
```

### 2.3 遍历示例：深度优先遍历所有元素节点

```javascript
function walkElements(node, callback) {
  callback(node);
  node = node.firstElementChild;
  while (node) {
    walkElements(node, callback);
    node = node.nextElementSibling;
  }
}

walkElements(document.body, (el) => {
  console.log(el.tagName);
});
```

### 2.4 检查节点存在性

在进行关系遍历时，务必检查节点是否为 `null`，避免错误。

---

## 3. 节点创建、插入、替换与删除

### 3.1 创建节点

| 方法                                | 描述                         |
| ----------------------------------- | ---------------------------- |
| `document.createElement(tagName)`   | 创建元素节点。               |
| `document.createTextNode(data)`     | 创建文本节点。               |
| `document.createComment(data)`      | 创建注释节点。               |
| `document.createDocumentFragment()` | 创建文档片段节点。           |
| `cloneNode(deep)`                   | 克隆节点（由已有节点调用）。 |

```javascript
const div = document.createElement('div');
const text = document.createTextNode('Hello');
div.appendChild(text);

const clone = div.cloneNode(true); // 深克隆，包含子节点
```

### 3.2 插入节点

**传统方式**（所有浏览器支持）：

- `parent.appendChild(newNode)`：将 `newNode` 添加为 `parent` 的最后一个子节点。
- `parent.insertBefore(newNode, referenceNode)`：将 `newNode` 插入到 `referenceNode` 之前。若 `referenceNode` 为 `null`，则等同于 `appendChild`。

```javascript
const list = document.getElementById('list');
const newItem = document.createElement('li');
newItem.textContent = 'New Item';
list.appendChild(newItem);

const firstItem = list.firstElementChild;
list.insertBefore(newItem, firstItem); // 插入到最前面
```

**现代方式**（较新浏览器支持，可链式调用）：

- `node.before(...nodes)` / `node.after(...nodes)`：在当前节点前/后插入一个或多个节点或字符串。
- `parent.append(...nodes)` / `parent.prepend(...nodes)`：在父节点的最后/最前插入一个或多个节点或字符串。

```javascript
const p = document.querySelector('p');
p.before('前置文本', document.createElement('span')); // 在 p 前插入
p.after('后置文本'); // 在 p 后插入

const container = document.getElementById('container');
container.append('新文本', document.createElement('div'));
```

### 3.3 替换节点

- **传统**：`parent.replaceChild(newNode, oldNode)`
- **现代**：`oldNode.replaceWith(...nodes)`

```javascript
// 传统
const old = document.getElementById('old');
const parent = old.parentNode;
const newSpan = document.createElement('span');
parent.replaceChild(newSpan, old);

// 现代
old.replaceWith(newSpan, '额外文本');
```

### 3.4 删除节点

- **传统**：`parent.removeChild(node)`
- **现代**：`node.remove()`

```javascript
// 传统
const node = document.getElementById('temp');
node.parentNode.removeChild(node);

// 现代
node.remove(); // 简洁，无需访问父节点
```

### 3.5 使用 DocumentFragment 批量插入

文档片段（`DocumentFragment`）是一个轻量级的容器，当插入到 DOM 树时，只会插入其子节点，片段本身不会出现。这减少了重排次数，提升性能。

```javascript
const fragment = document.createDocumentFragment();
for (let i = 0; i < 100; i++) {
  const li = document.createElement('li');
  li.textContent = `Item ${i}`;
  fragment.appendChild(li);
}
document.getElementById('list').appendChild(fragment); // 一次插入
```

### 3.6 插入 HTML 字符串

- `element.insertAdjacentHTML(position, htmlString)`：在指定位置插入 HTML 字符串。`position` 可以是：
  - `'beforebegin'`：元素自身之前
  - `'afterbegin'`：元素内部，第一个子节点之前
  - `'beforeend'`：元素内部，最后一个子节点之后
  - `'afterend'`：元素自身之后

```javascript
const div = document.querySelector('div');
div.insertAdjacentHTML('afterend', '<p>插入的段落</p>');
```

类似的方法还有 `insertAdjacentElement()` 和 `insertAdjacentText()`。

---

## 4. 属性与样式操作

### 4.1 操作 HTML 属性

- **获取属性**：`element.getAttribute(name)`，若无则返回 `null`。
- **设置属性**：`element.setAttribute(name, value)`。
- **移除属性**：`element.removeAttribute(name)`。
- **检查属性**：`element.hasAttribute(name)`。

```javascript
const input = document.querySelector('input');
input.setAttribute('placeholder', '请输入姓名');
console.log(input.getAttribute('type'));
if (input.hasAttribute('disabled')) {
  input.removeAttribute('disabled');
}
```

对于标准属性（如 `id`、`name`、`value`），可以直接通过元素对象属性访问：

```javascript
input.id = 'username';
input.value = 'Alice';
```

### 4.2 操作类名

- **`className`**：以字符串形式获取/设置所有类名。
- **`classList`**：提供一组方法操作类名，更推荐：
  - `add(className)`：添加类。
  - `remove(className)`：移除类。
  - `toggle(className, force?)`：切换类，若第二个参数为布尔值则强制添加/移除。
  - `contains(className)`：检查是否包含类。
  - `replace(oldClass, newClass)`：替换类。

```javascript
const box = document.getElementById('box');
box.classList.add('active', 'highlight');
box.classList.remove('inactive');
box.classList.toggle('visible');
if (box.classList.contains('error')) {
  console.log('有错误类');
}
```

### 4.3 操作内联样式

- **`style` 属性**：一个 `CSSStyleDeclaration` 对象，可以通过驼峰式属性名设置内联样式。

```javascript
const elem = document.querySelector('.animated');
elem.style.backgroundColor = 'red';
elem.style.fontSize = '20px';
elem.style.cssText = 'color: blue; margin: 10px;'; // 批量设置
```

**注意**：读取 `style` 属性只能获取内联样式，无法获取外部 CSS 定义的样式。要获取计算后的样式，使用 `getComputedStyle`。

- **`window.getComputedStyle(element, pseudoElement?)`**：返回元素的所有最终使用的 CSS 属性值（只读）。

```javascript
const computed = getComputedStyle(elem);
console.log(computed.backgroundColor);
```

### 4.4 操作数据属性（dataset）

HTML5 允许在元素上自定义 `data-*` 属性，通过 `dataset` 对象访问，属性名转为驼峰式。

```html
<div id="user" data-user-id="123" data-role="admin"></div>
```

```javascript
const user = document.getElementById('user');
console.log(user.dataset.userId); // "123"
console.log(user.dataset.role);   // "admin"
user.dataset.status = 'active';   // 添加 data-status="active"
```

---

## 5. 滚动行为

控制页面或元素的滚动位置是交互中常见的需求。

### 5.1 窗口滚动

- **`window.scrollTo(x, y)`**：滚动到指定坐标。
- **`window.scrollBy(x, y)`**：相对当前位置滚动指定偏移量。
- **`window.scrollTo(options)`**：接受包含 `top`、`left` 和 `behavior` 的对象，`behavior` 可为 `'smooth'` 实现平滑滚动。

```javascript
// 绝对滚动
window.scrollTo(0, 500);
// 平滑滚动到顶部
window.scrollTo({ top: 0, behavior: 'smooth' });

// 相对滚动
window.scrollBy(0, 100); // 向下滚动 100px
```

### 5.2 元素滚动

每个元素也有类似的滚动方法：

- **`element.scrollIntoView(options?)`**：滚动父容器使元素可见。`options` 可以是布尔值（`true` 表示顶端对齐，`false` 表示底端对齐）或包含 `behavior`、`block`、`inline` 的对象。

```javascript
document.getElementById('section2').scrollIntoView({ behavior: 'smooth', block: 'center' });
```

- **`element.scrollTo`、`element.scrollBy`**：与窗口方法类似，作用于元素的滚动条。

- **`element.scrollTop` / `element.scrollLeft`**：获取或设置元素滚动条的位置。

```javascript
const container = document.querySelector('.scrollable');
console.log(container.scrollTop); // 获取已滚动距离
container.scrollTop = 200;        // 设置滚动位置
```

### 5.3 检测滚动位置

- **`window.scrollX` / `window.scrollY`**：获取窗口水平/垂直滚动距离。
- **`element.scrollHeight` / `element.scrollWidth`**：获取元素内容的总高度/宽度（包括不可见部分）。
- **`element.clientHeight` / `element.clientWidth`**：获取元素的可见区域高度/宽度。
- **`element.offsetHeight` / `element.offsetWidth`**：获取元素布局高度（包括边框和内边距）。

示例：判断是否滚动到底部

```javascript
const container = document.querySelector('.scrollable');
const isBottom = container.scrollHeight - container.scrollTop === container.clientHeight;
```

---

## 6. 综合示例：动态创建并插入卡片

以下示例演示了从获取、创建、插入到样式修改的完整流程。

```html
<div id="card-container"></div>
<button id="add-card">添加卡片</button>
```

```javascript
const container = document.getElementById('card-container');
const addBtn = document.getElementById('add-card');

addBtn.addEventListener('click', () => {
  // 创建卡片元素
  const card = document.createElement('div');
  card.className = 'card';

  // 创建标题
  const title = document.createElement('h3');
  title.textContent = `卡片 ${container.children.length + 1}`;
  
  // 创建内容
  const content = document.createElement('p');
  content.textContent = '这是卡片内容，可以动态插入。';

  // 组装卡片
  card.appendChild(title);
  card.appendChild(content);

  // 设置样式（或通过类名定义）
  card.style.border = '1px solid #ccc';
  card.style.padding = '10px';
  card.style.margin = '5px';

  // 添加到容器
  container.append(card);

  // 滚动到新卡片
  card.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
});
```

---

## 7. 最佳实践与性能优化

1. **缓存 DOM 查询**  
   避免在循环中反复查询相同的节点，应将结果存储在变量中。

2. **批量操作使用文档片段**  
   需要插入多个同级节点时，先添加到 `DocumentFragment`，再一次性插入。

3. **避免强制同步布局**  
   反复读写影响布局的属性（如 `offsetHeight`、`scrollTop`）可能导致布局抖动。尽量批量读取，或使用 `requestAnimationFrame`。

4. **使用 `classList` 代替 `className` 字符串操作**  
   `classList` 更清晰，且不会意外覆盖其他类。

5. **事件委托**  
   对于动态添加的元素，将事件监听器绑定到父元素上，利用事件冒泡处理，避免为每个新节点单独绑定。

6. **现代 API 优先**  
   使用 `append`、`prepend`、`before`、`after`、`replaceWith`、`remove` 等现代方法，代码更简洁。

7. **安全性考虑**  
   当使用 `innerHTML` 或 `insertAdjacentHTML` 插入用户提供的内容时，务必转义或使用安全的文本方法（如 `textContent`），防止 XSS 攻击。

---

## 小结

本章全面介绍了节点操作的核心技术：

- **获取节点**：通过 id、标签、类名、选择器等多种方式。
- **遍历与关系**：利用父子、兄弟属性在节点树中移动。
- **创建/插入/替换/删除**：从创建新节点到动态修改文档结构。
- **属性与样式操作**：控制元素的行为和外观。
- **滚动行为**：控制窗口和元素的滚动位置。

掌握这些操作，你就能动态地构建和修改页面，响应用户交互，实现丰富的客户端功能。在下一节中，我们将深入**事件系统**，学习如何处理用户触发的事件。
