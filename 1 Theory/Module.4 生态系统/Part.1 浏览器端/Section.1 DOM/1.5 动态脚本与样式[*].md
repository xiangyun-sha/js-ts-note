# 生态系统 · 浏览器端 · 动态脚本与样式

在复杂的 Web 应用中，我们常常需要根据用户行为或运行时状态动态加载额外的 JavaScript 脚本或 CSS 样式。这种“动态”能力不仅能减少初始加载体积、提升性能，还能实现主题切换、按需加载等功能。本章将介绍如何通过 JavaScript 动态地加载和管理脚本与样式，以及相关的注意事项。

---

## 1. 概述

### 1.1 什么是动态脚本与样式？

- **动态脚本**：在页面加载完成后，通过 JavaScript 动态创建 `<script>` 元素并插入到 DOM 中，从而加载和执行额外的 JavaScript 代码。可以是外部文件，也可以是内联代码。
- **动态样式**：类似地，动态创建 `<link>` 或 `<style>` 元素加载或定义 CSS 规则，从而改变页面的外观。

### 1.2 使用场景

- **按需加载**：路由懒加载（如单页应用中的代码拆分）、按需加载某些功能模块。
- **主题切换**：动态切换 CSS 文件（如白天/夜间模式）。
- **A/B 测试**：根据实验动态加载不同的脚本。
- **第三方服务**：异步加载分析脚本、广告脚本等。
- **用户自定义样式**：允许用户自定义主题并动态应用。

---

## 2. 动态脚本

### 2.1 动态加载外部脚本

最常用的方法是创建一个新的 `<script>` 元素，设置其 `src` 属性，然后将其添加到 DOM 中。

```javascript
function loadScript(src, callback) {
  const script = document.createElement('script');
  script.src = src;
  script.onload = () => callback(null, script);
  script.onerror = () => callback(new Error(`加载失败: ${src}`));
  document.head.appendChild(script);
}

// 使用
loadScript('https://example.com/widget.js', (err, script) => {
  if (err) {
    console.error(err);
  } else {
    console.log('脚本加载成功');
  }
});
```

#### 注意事项

- **加载顺序**：脚本会按照插入顺序执行，但依赖关系可能需要手动控制（如使用回调或 Promise）。
- **缓存**：浏览器会正常缓存通过这种方式加载的脚本。
- **跨域**：跨域脚本加载没有问题，但 `onerror` 可能无法捕获详细的错误信息。

### 2.2 动态执行内联脚本

如果需要动态生成并执行一段 JavaScript 代码，可以创建 `<script>` 元素并设置其 `textContent`。

```javascript
const script = document.createElement('script');
script.textContent = 'console.log("这是动态执行的内联脚本");';
document.head.appendChild(script);
```

**安全警告**：动态执行代码等同于 `eval()`，存在严重的安全风险（XSS）。除非代码来源完全可信且经过严格转义，否则应避免此做法。

### 2.3 使用 `async` 和 `defer` 属性

通过设置 `<script>` 的 `async` 或 `defer` 属性可以控制脚本的加载和执行时机，与静态脚本的行为一致。

```javascript
const script = document.createElement('script');
script.src = 'analytics.js';
script.async = true; // 异步加载，加载完成后立即执行
document.head.appendChild(script);
```

### 2.4 检测脚本加载完成

除了 `onload` 和 `onerror`，还可以监听 `load` 事件。对于已加载过的脚本，重复添加相同 `src` 的 `<script>` 可能会导致重复加载，因此可能需要记录已加载的脚本状态。

```javascript
const loadedScripts = new Set();

function loadScriptOnce(src) {
  if (loadedScripts.has(src)) {
    return Promise.resolve();
  }
  return new Promise((resolve, reject) => {
    const script = document.createElement('script');
    script.src = src;
    script.onload = () => {
      loadedScripts.add(src);
      resolve();
    };
    script.onerror = reject;
    document.head.appendChild(script);
  });
}
```

---

## 3. 动态样式

### 3.1 动态加载外部样式表

创建 `<link>` 元素并插入到 `<head>` 中。

```javascript
function loadCSS(href, callback) {
  const link = document.createElement('link');
  link.rel = 'stylesheet';
  link.href = href;
  link.onload = () => callback && callback(null, link);
  link.onerror = () => callback && callback(new Error(`样式加载失败: ${href}`));
  document.head.appendChild(link);
}

// 切换主题
document.getElementById('theme-toggle').addEventListener('click', () => {
  loadCSS('dark-theme.css', () => console.log('主题已切换'));
});
```

**注意**：`<link>` 元素的 `onload` 事件通常能够可靠地触发，但某些旧版浏览器可能需要使用 `onreadystatechange` 作为备选。

### 3.2 动态创建内联样式

使用 `<style>` 元素动态添加 CSS 规则。

```javascript
const style = document.createElement('style');
style.textContent = `
  body {
    background-color: lightblue;
  }
  .highlight {
    color: red;
    font-weight: bold;
  }
`;
document.head.appendChild(style);
```

如果需要修改现有样式，可以直接操作 `style` 属性或 `classList`，但有时需要全局动态样式，这种方式更合适。

### 3.3 使用 CSSStyleSheet 对象（Constructible Stylesheets）

现代浏览器支持通过 `new CSSStyleSheet()` 创建可构造的样式表对象，并可以将其应用到 Shadow DOM 或全局文档。这对于动态样式管理（特别是 Web Components）非常有用。

```javascript
// 创建一个新的样式表
const sheet = new CSSStyleSheet();
sheet.replaceSync(`
  .my-class {
    color: green;
    font-size: 20px;
  }
`);

// 应用到全局文档
document.adoptedStyleSheets = [sheet];

// 或者应用到 Shadow DOM
shadowRoot.adoptedStyleSheets = [sheet];
```

可以使用 `replace()` 方法异步加载外部样式。

```javascript
const sheet = new CSSStyleSheet();
sheet.replace('@import url("styles.css")').then(() => {
  document.adoptedStyleSheets = [sheet];
});
```

### 3.4 操作现有样式表

通过 `document.styleSheets` 可以访问文档中所有样式表（包括内联和外部）。但需要注意跨域限制：不同域的外部样式表无法读取其规则。

```javascript
// 遍历所有样式表
for (const sheet of document.styleSheets) {
  try {
    const rules = sheet.cssRules || sheet.rules; // 规则列表
    for (const rule of rules) {
      if (rule.selectorText === '.dynamic') {
        rule.style.color = 'red'; // 修改规则
      }
    }
  } catch (e) {
    console.warn('无法读取跨域样式表', e);
  }
}

// 动态添加规则
const sheet = document.styleSheets[0];
sheet.insertRule('.new-class { background: yellow; }', sheet.cssRules.length);

// 删除规则
sheet.deleteRule(0);
```

**注意**：操作外部样式表受同源策略限制，且可能影响性能，应谨慎使用。

---

## 4. 动态加载的顺序与控制

### 4.1 脚本依赖管理

当动态加载多个具有依赖关系的脚本时，需要确保加载顺序正确。可以使用 Promise 链或异步队列。

```javascript
async function loadScriptsInOrder(urls) {
  for (const url of urls) {
    await new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = url;
      script.onload = resolve;
      script.onerror = reject;
      document.head.appendChild(script);
    });
  }
}
```

### 4.2 并行加载与执行顺序

如果脚本没有依赖关系，可以使用 `async` 属性并行加载，但执行顺序不确定。如果希望并行加载但按顺序执行，可以使用 `defer` 属性（但 `defer` 只对外部脚本有效，且不会在动态插入时生效）。通常手动控制更可靠。

### 4.3 样式加载与依赖

样式表加载通常不会阻塞页面渲染，但如果后续 JavaScript 依赖于新样式生效（例如获取元素尺寸），可能需要确保样式加载完成。可以通过 `onload` 监听。

---

## 5. 性能优化

### 5.1 按需加载

只在需要时加载资源，减少首屏请求和带宽占用。结合路由懒加载或用户交互触发。

### 5.2 预加载与预连接

使用 `<link rel="preload">` 或 `<link rel="preconnect">` 提前加载关键资源。可以动态创建这些标签。

```javascript
const preloadLink = document.createElement('link');
preloadLink.rel = 'preload';
preloadLink.as = 'script';
preloadLink.href = 'critical.js';
document.head.appendChild(preloadLink);
```

### 5.3 避免重复加载

记录已加载的脚本/样式 URL，防止重复添加，节省网络请求。

### 5.4 使用 `requestIdleCallback` 延迟加载非关键资源

```javascript
requestIdleCallback(() => {
  loadScript('analytics.js');
});
```

---

## 6. 安全注意事项

### 6.1 避免动态执行不可信代码

动态创建 `<script>` 并插入内联代码（或通过 `eval`）会带来 XSS 风险。永远不要将用户输入直接作为代码执行。

### 6.2 内容安全策略（CSP）

如果网站启用了 CSP，动态加载外部脚本和样式可能会被策略阻止。需要确保加载的资源符合 CSP 规则（如使用 nonce 或 hash）。

例如，对于内联样式，CSP 可能会禁止 `style-src unsafe-inline`，此时需要使用 nonce：

```javascript
const style = document.createElement('style');
style.nonce = 'r@nd0m'; // 与服务器生成的 nonce 一致
style.textContent = 'body { color: red; }';
document.head.appendChild(style);
```

### 6.3 避免跨域样式表访问

跨域样式表的 `cssRules` 无法读取，但插入规则或加载新样式不受影响。

---

## 7. 综合示例：主题切换器

以下示例演示了动态切换样式表和加载对应脚本的简单实现。

```html
<button id="theme-light">浅色主题</button>
<button id="theme-dark">深色主题</button>
<div id="content">这是一个可切换主题的内容。</div>
```

```javascript
function setTheme(themeName) {
  // 移除已有的主题链接
  const existingLink = document.getElementById('theme-link');
  if (existingLink) existingLink.remove();

  // 创建新的主题样式链接
  const link = document.createElement('link');
  link.id = 'theme-link';
  link.rel = 'stylesheet';
  link.href = `${themeName}.css`;
  link.onload = () => console.log(`${themeName} 主题已加载`);

  // 可能还需要加载对应的脚本
  loadScript(`${themeName}.js`);

  document.head.appendChild(link);
}

function loadScript(src) {
  const script = document.createElement('script');
  script.src = src;
  script.async = true;
  document.head.appendChild(script);
}

document.getElementById('theme-light').addEventListener('click', () => setTheme('light'));
document.getElementById('theme-dark').addEventListener('click', () => setTheme('dark'));
```

---

## 8. 最佳实践

1. **使用 Promise 封装加载逻辑**，便于管理异步流程。
2. **避免重复加载**：维护一个已加载资源池。
3. **考虑错误处理**：网络失败时应提供 fallback 或重试机制。
4. **优先使用 `<link rel="preload">`** 提前加载重要资源。
5. **动态样式尽量使用 `classList` 切换**，而不是频繁创建 `<style>` 标签，以减少重排开销。
6. **对于 Web Components，使用 Constructible Stylesheets** 提升性能和封装性。
7. **遵守 CSP 规则**，不要绕过安全策略。

---

## 小结

动态脚本和样式是现代 Web 应用实现按需加载、主题切换、代码拆分等技术的基础。通过熟练掌握 `<script>` 和 `<link>` 的动态创建与管理，以及现代 API（如 `CSSStyleSheet`），我们可以构建出更灵活、性能更优的应用。同时，必须牢记安全风险，确保动态内容来源可信，并遵循内容安全策略。

在下一节中，我们将继续探讨浏览器端的其他进阶话题，如**性能监控**与**错误跟踪**。
